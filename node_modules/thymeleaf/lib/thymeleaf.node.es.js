import { flatten, remove } from '@ultraq/array-utils';
import { merge, navigate } from '@ultraq/object-utils';
import { escapeHtml } from '@ultraq/string-utils';
import { $ } from 'dumb-query-selector';

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A special kind of expression that requires the referenced rule consume all
 * available input.
 * 
 * @param {String} ruleName
 * @return {Matchable}
 */
const AllInput = ruleName => (input, parser) => {
  let matchResult = parser.parseWithExpression(input, ruleName);
  return matchResult !== null && input.exhausted() ? matchResult : null;
};

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A collection of Rules that describes a language.
 * 
 * @author Emanuel Rabina
 */
class Grammar {

	/**
  * @param {String} name
  * @param {Rule} startingRule
  * @param {...Rule} additionalRules
  */
	constructor(name, startingRule) {

		this.name = name;

		for (var _len = arguments.length, additionalRules = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			additionalRules[_key - 2] = arguments[_key];
		}

		this.rules = [].concat(startingRule, additionalRules);
	}

	/**
  * Given an input string and a parser, return whether or not the input is
  * accepted by this grammar.
  * 
  * @param {InputBuffer} input
  * @param {Parser} parser
  * @return {Object} If the input is accepted, this will be the non-null result
  *   of matching against the rules of this grammar.
  */
	accept(input, parser) {

		return this.startingRule.accept(input, parser);
	}

	/**
  * Return the rule that has the given name.
  * 
  * @param {String} name
  * @return {Rule}
  */
	findRuleByName(name) {

		let rule = this.rules.find(rule => rule.name === name);
		if (!rule) {
			throw new Error(`Failed to find a rule named "${name}" in the grammar`);
		}
		return rule;
	}

	/**
  * Returns the grammar's starting rule.
  * 
  * @return {Rule}
  */
	get startingRule() {

		return this.rules[0];
	}
}

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns an expression function where the underlying expression doesn't need
 * to be matched.  Thus, optional expressions "always" match.
 * 
 * @param {Matchable} expression
 * @return {Matchable}
 */
const Optional = expression => (input, parser) => {
	return input.markAndClearOrReset(() => {
		let result = parser.parseWithExpression(input, expression);
		return result !== null ? result : '';
	});
};

/**
 * Returns an expression function where the expression must be matched against
 * at least once to be considered a match.
 * 
 * @param {Matchable} expression
 * @return {Matchable}
 */
const OneOrMore = expression => (input, parser) => {
	return input.markAndClearOrReset(() => {
		let results = [];
		while (true) {
			let result = input.markAndClearOrReset(() => {
				return parser.parseWithExpression(input, expression);
			});
			if (result) {
				results.push(result);
			} else {
				break;
			}
		}
		return results.length > 0 ? results : null;
	});
};

/**
 * Returns an expression function where only one of the underlying expressions
 * must be matched in order to consider the expression a match.
 * 
 * @param {...Matchable} expressions
 * @return {Matchable}
 */
const OrderedChoice = function OrderedChoice() {
	for (var _len = arguments.length, expressions = Array(_len), _key = 0; _key < _len; _key++) {
		expressions[_key] = arguments[_key];
	}

	return (input, parser) => {
		return input.markAndClearOrReset(() => {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = expressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					let expression = _step.value;

					let result = input.markAndClearOrReset(() => {
						return parser.parseWithExpression(input, expression);
					});
					if (result !== null) {
						return result;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return null;
		});
	};
};

/**
 * Returns an expression whose underlying expressions must be matched in order
 * to consider the entire expression a match.
 * 
 * @param {...Matchable} expressions
 * @return {Matchable}
 */
const Sequence = function Sequence() {
	for (var _len2 = arguments.length, expressions = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		expressions[_key2] = arguments[_key2];
	}

	return (input, parser) => {
		return input.markAndClearOrReset(() => {
			let results = [];
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = expressions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					let expression = _step2.value;

					let result = input.markAndClearOrReset(() => {
						return parser.parseWithExpression(input, expression);
					});
					if (result === null) {
						return null;
					}
					results.push(result);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return results;
		});
	};
};

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();



var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};











var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};





















var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();











var toArray = function (arr) {
  return Array.isArray(arr) ? arr : Array.from(arr);
};

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Wrapper around the string being parsed, with a position that keeps track of
 * what part of the imput is currently being read/tested.
 * 
 * @author Emanuel Rabina
 */
class InputBuffer {

	/**
  * @param {String} input
  */


	/**
  * @private
  * @type {Number}
  */
	constructor(input) {
		this.position = 0;
		this.positionStack = [];


		this.input = input;
	}

	/**
  * Clear the previously {@link #mark}ed position.
  */


	/**
  * @private
  * @type {Array<Number>}
  */
	clear() {

		let lastPosition = this.positionStack.pop();
		if (lastPosition === undefined) {
			throw new Error('Called clear() but no matching mark()');
		}
	}

	/**
  * Returns whether or not the current position is at the end of the input,
  * meaning we've exhausted the entire input string.
  * 
  * @return {Boolean}
  */
	exhausted() {

		return this.position === this.input.length;
	}

	/**
  * Sets a mark at the current position so that it can be returned to by a
  * matching {@link #reset} call.
  */
	mark() {

		this.positionStack.push(this.position);
	}

	/**
  * Convenience method for surrounding a function with a call to {@link #mark},
  * then {@link #clear} if the result of the function is non-null, or
  * {@link #reset} if `null`.
  * 
  * @template T
  * @param {Function<T>} func
  * @return {T}
  */
	markAndClearOrReset(func) {

		this.mark();
		let result = func();
		if (result !== null) {
			this.clear();
			return result;
		}
		this.reset();
		return null;
	}

	/**
  * Reads as many characters from the current position as satisfies the given
  * pattern, returning the read characters and advancing the mark by as many
  * characters.
  * 
  * @param {RegExp} pattern
  * @return {Array} The array of matched strings, or `null` if the pattern
  *   didn't match.
  */
	read(pattern) {

		let remaining = this.input.substring(this.position);
		let leadingWhitespace = remaining.match(/^\s+/);
		if (leadingWhitespace) {
			leadingWhitespace = leadingWhitespace[0];
			remaining = remaining.substring(leadingWhitespace.length);
		}
		let result = new RegExp(pattern.source).exec(remaining);
		if (result) {
			var _result = slicedToArray(result, 1);

			let value = _result[0];

			if (remaining.startsWith(value)) {
				this.position += value.length + (leadingWhitespace ? leadingWhitespace.length : 0);
				return result;
			}
		}
		return null;
	}

	/**
  * Revert to the last @{link #mark}ed position.
  */
	reset() {

		let newPosition = this.positionStack.pop();
		if (newPosition === undefined) {
			throw new Error('Called reset() but no matching mark()');
		}
		this.position = newPosition;
	}
}

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A special kind of expression that understands matched portions of regular
 * expressions to run processing over, which may lead to additional parsing
 * expressions.
 * 
 * This expression should be used sparingly as the regexes within need to take
 * care of whitespace between tokens themselves, which can be annoying.
 * 
 * @param {RegExp} expression
 * @param {Array<Matchable>} matchers
 * @return {Matchable}
 */
const RegularExpression = (expression, matchers) => (input, parser) => {
  return input.markAndClearOrReset(() => {
    let result = input.read(expression);
    if (result) {
      let parseResults = [result[0]];
      for (let i = 1; i < result.length; i++) {
        let match = result[i];
        if (match !== undefined) {
          let parseResult = parser.parseWithExpression(new InputBuffer(match), matchers[i - 1]);
          if (parseResult === null) {
            return null;
          }
          parseResults.push(parseResult);
        }
      }
      return parseResults;
    }
    return null;
  });
};

/*
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Default processor which returns the result as is.
 * 
 * @template T
 * @param {T} result
 * @return {T}
 */
function defaultMatchProcessor(result) {
  return result;
}

/**
 * A rule describes a string in the language.
 * 
 * @author Emanuel Rabina
 */
class Rule {

  /**
   * @param {String} name
   * @param {Object} expression
   * @param {Function} [matchProcessor=defaultExpressionAction]
   */
  constructor(name, expression) {
    let matchProcessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultMatchProcessor;


    this.name = name;
    this.expression = expression;
    this.matchProcessor = matchProcessor;
  }

  /**
   * Given an input string and a parser, return whether or not the input is
   * accepted by this rule.
   * 
   * @param {InputBuffer} input
   * @param {Parser} parser
   * @return {Object} If the input is accepted, this will be the non-null result
   *   of matching against the rule.
   */
  accept(input, parser) {

    let matchResult = parser.parseWithExpression(input, this.expression);
    return matchResult !== null ? this.matchProcessor(matchResult) : null;
  }
}

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Grammar for the Thymeleaf expression language.  Describes the language and
 * how to parse it.
 * 
 * @author Emanuel Rabina
 */
var ThymeleafExpressionLanguage = new Grammar('Thymeleaf Expression Language',

// Ordered as at https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#standard-expression-syntax
new Rule('ThymeleafExpression', OrderedChoice(AllInput('VariableExpression'), AllInput('LinkExpression'), AllInput('FragmentExpression'), AllInput('Iteration'), AllInput('StringConcatenation'), AllInput('Literal'), AllInput('LogicalExpression'), AllInput('IfThenCondition'), AllInput('IfThenElseCondition'), AllInput('Nothing'))),

// Simple expressions
// ==================

/**
 * Variable expressions, `${variable}`.  Represents a value to be retrieved
 * from the current context.
 */
new Rule('VariableExpression', Sequence(/\${/, 'Identifier', /\}/), (_ref) => {
	var _ref2 = slicedToArray(_ref, 2);

	let identifier = _ref2[1];
	return context => {
		let result = navigate(context, identifier);
		return result !== null && result !== undefined ? result : '';
	};
}),

/**
 * Link expressions, `@{url(parameters)}`.  Used for generating URLs out of
 * context parameters.
 */
new Rule('LinkExpression', RegularExpression(/^@\{(.+?)(\(.+\))?\}$/, ['Url', 'UrlParameters']), (_ref3) => {
	var _ref4 = slicedToArray(_ref3, 3);

	let url = _ref4[1],
	    parameters = _ref4[2];
	return context => {

		if (parameters) {

			// TODO: Push this parsing of the parameters list back into the grammar
			let expressionProcessor = new ExpressionProcessor(context);
			let paramsList = parameters.slice(1, -1).split(',').map(param => {
				var _param$split = param.split('='),
				    _param$split2 = slicedToArray(_param$split, 2);

				let lhs = _param$split2[0],
				    rhs = _param$split2[1];

				return [lhs, expressionProcessor.process(rhs)];
			});

			// Fill out any placeholders in the URL from the parameters
			while (true) {
				// eslint-disable-line
				let urlTemplate = /(.*?)\{(.+?)\}(.*)/.exec(url);
				if (urlTemplate) {
					var _urlTemplate = slicedToArray(urlTemplate, 4);

					let head = _urlTemplate[1],
					    placeholder = _urlTemplate[2],
					    tail = _urlTemplate[3];

					let paramEntry = remove(paramsList, (_ref5) => {
						var _ref6 = slicedToArray(_ref5, 1);

						let lhs = _ref6[0];
						return lhs === placeholder;
					});
					if (paramEntry) {
						url = `${head}${paramEntry[1]}${tail}`;
					}
				} else {
					break;
				}
			}

			// Remaining parameters become search query parameters
			if (paramsList.length) {
				url += `?${paramsList.map((_ref7) => {
					var _ref8 = slicedToArray(_ref7, 2);

					let key = _ref8[0],
					    value = _ref8[1];
					return `${key}=${value}`;
				}).join('&')}`;
			}
		}
		return url;
	};
}), new Rule('Url', /.+/), new Rule('UrlParameters', /\((.+)\)/),

/**
 * Fragment expressions, `~{template :: fragment(parameters)}`.  A locator for
 * a piece of HTML in the same or another template.
 */
new Rule('FragmentExpression', Sequence(/~{/, 'TemplateName', /::/, 'FragmentName', 'FragmentParameters', /}/), (_ref9) => {
	var _ref10 = slicedToArray(_ref9, 5);

	let templateName = _ref10[1],
	    fragmentName = _ref10[3],
	    parameters = _ref10[4];
	return () => {

		// TODO: Should executing a fragment expression locate and return the
		//       fragment?  If so, then it'll make expression execution
		//       asynchronous!
		return {
			templateName,
			fragmentName,
			parameters
		};
	};
}), new Rule('TemplateName', /[\w-._]+/), new Rule('FragmentName', /[\w-._]+/),

// TODO: We're not doing anything with these yet
new Rule('FragmentParameters', Optional(/\(.+\)/)),

// Complex expressions
// ===================

/**
 * Iteration, `localVar : ${collection}`.  The name of the variable for each
 * loop, followed by the collection being iterated over.
 */
new Rule('Iteration', Sequence('Identifier', Optional(Sequence(/,/, 'Identifier')), /:/, 'VariableExpression'), (_ref11) => {
	var _ref12 = slicedToArray(_ref11, 4);

	let localValueName = _ref12[0];

	var _ref12$ = slicedToArray(_ref12[1], 2);

	let iterationStatusVariable = _ref12$[1],
	    collectionExpressionAction = _ref12[3];
	return context => ({
		localValueName,
		iterable: collectionExpressionAction(context),
		iterationStatusVariable
	});
}),

/**
 * String concatenation, `'...' + '...'` or even `${...} + ${...}`, the
 * joining of 2 expressions by way of the `+` operator.
 */
new Rule('StringConcatenation', Sequence('Concatenatable', OneOrMore(Sequence(/\+/, 'Concatenatable'))), (_ref13) => {
	var _ref14 = slicedToArray(_ref13, 2);

	let first = _ref14[0];

	var _ref14$ = toArray(_ref14[1]);

	let rest = _ref14$.slice(0);

	return context => {
		const coerce = value => typeof value === 'function' ? value(context) : value.toString();
		return coerce(first) + rest.reduce((result, _ref15) => {
			var _ref16 = slicedToArray(_ref15, 2);

			let item = _ref16[1];
			return result + coerce(item);
		}, '');
	};
}), new Rule('Concatenatable', OrderedChoice('StringLiteral', 'VariableExpression')),

// Literals
// ========

new Rule('Literal', OrderedChoice('StringLiteral', 'NumberLiteral', 'BooleanLiteral', 'NullLiteral', 'TokenLiteral')),

/**
 * String literal, characters surrounded by `'` (single quotes).
 */
new Rule('StringLiteral', /'.*?'/, result => () => result.slice(1, -1)),

/**
 * A number.
 */
new Rule('NumberLiteral', /\d+(\.\d+)?/, result => () => parseFloat(result)),

/**
 * One of `true` or `false`.
 */
new Rule('BooleanLiteral', /(true|false)/, result => () => result === 'true'),

/**
 * The word `null` to represent the null value.
 */
// TODO: The parser uses null to mean 'failed parse', so this might not work?
new Rule('NullLiteral', /null/, () => () => null),

/**
 * A token literal, which is pretty much anything else that can't be categorized
 * by the other literal types.  This is often used as a fallback in the
 * expression language so that, for any unknown input, we're still returning
 * something.
 */
// TODO: Is this the same as an Identifier?
new Rule('TokenLiteral', /[^: ${}]+/, result => () => result),

// Text operations
// ===============


// Arithmetic operations
// =====================


// Boolean operations
// ==================


// Comparisons and equality
// ========================

/**
 * A logical expression is any expression that resolves in a `true`/`false`
 * value.
 */
new Rule('LogicalExpression', Sequence('Operand', 'Comparator', 'Operand'), (_ref17) => {
	var _ref18 = slicedToArray(_ref17, 3);

	let leftOperand = _ref18[0],
	    comparator = _ref18[1],
	    rightOperand = _ref18[2];
	return context => {
		let lhs = leftOperand(context);
		let rhs = rightOperand(context);
		switch (comparator) {
			case '==':
				return lhs == rhs;
			case '===':
				return lhs === rhs;
		}
		return false;
	};
}), new Rule('Comparator', OrderedChoice(/===?/)),

// Conditional operators
// =====================

/**
 * If-then condition, `if ? then`.  This is the truthy branch only of the
 * classic ternary operator.  The falsey branch is a no-op.
 */
new Rule('IfThenCondition', Sequence('Condition', /\?/, 'Operand'), (_ref19) => {
	var _ref20 = slicedToArray(_ref19, 3);

	let condition = _ref20[0],
	    truthyExpression = _ref20[2];
	return context => {
		return condition(context) ? truthyExpression(context) : undefined;
	};
}),

/**
 * If-then-else condition, `if ? then : else`, the classic ternary operator.
 */
new Rule('IfThenElseCondition', Sequence('Condition', /\?/, 'Operand', /:/, 'Operand'), (_ref21) => {
	var _ref22 = slicedToArray(_ref21, 5);

	let condition = _ref22[0],
	    truthyExpression = _ref22[2],
	    falseyExpression = _ref22[4];
	return context => {
		return condition(context) ? truthyExpression(context) : falseyExpression(context);
	};
}),

/**
 * A condition is some expression or value that resolves to a true/false
 * value.
 */
new Rule('Condition', OrderedChoice('LogicalExpression', 'Operand')),

// Special tokens
// ==============

/**
 * An expression that matches the empty string.
 */
new Rule('Nothing', /^$/),

// Common language basics
// ======================

new Rule('Identifier', /[a-zA-Z_][\w.]*/),

/**
 * An operand is either a variable or a literal.
 */
new Rule('Operand', OrderedChoice('VariableExpression', 'Literal')));

/*
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Any one of the objects that can be matched:
 *  - an expression function
 *  - a string that references another rule
 *  - a regular expression
 * 
 * @typedef {String|RegExp|Function} Matchable
 */

/**
 * A recursive descent parser for any parsing expression grammar defined by the
 * constructs in this module.
 * 
 * TODO: Own module?
 * 
 * @author Emanuel Rabina
 */
class Parser {

	/**
  * @param {Grammar} grammar
  */
	constructor(grammar) {

		this.grammar = grammar;
	}

	/**
  * Parse a string, attempting to build the parse tree defined by the rules in
  * the configured grammar.  Parsing is considered successful when there are no
  * more non-terminating symbols in the grammar and all of the input has been
  * read.
  * 
  * @param {String} input
  * @return {Object} The parse tree if the input could be parsed, `null`
  *   otherwise.
  */
	parse(input) {

		let inputBuffer = new InputBuffer(input);
		let matchResult = this.grammar.accept(inputBuffer, this);
		if (matchResult === null || !inputBuffer.exhausted()) {
			let errorMessage = `Failed to parse "${input}"`;

			// Don't bring down the thread if we can't parse
			if (process.env.NODE_ENV === 'production') {
				console.error(errorMessage);
				return null;
			} else {
				throw new Error(errorMessage);
			}
		}
		return matchResult;
	}

	/**
  * Parse the input against the given expression.  An expression can either be
  * a reference to another rule in the current grammar, or a regular expression
  * that consumes input.
  * 
  * @param {InputBuffer} input
  * @param {Matchable} expression
  * @return {Object}
  */
	parseWithExpression(input, expression) {

		// Name of another rule in the grammar
		if (typeof expression === 'string') {
			let rule = this.grammar.findRuleByName(expression);
			return rule ? rule.accept(input, this) : null;
		}

		// A regular expression that must be matched
		else if (expression instanceof RegExp) {
				let result = input.read(expression);
				if (result) {
					return result[0];
				}
			}

			// An expression function to be executed
			else if (typeof expression === 'function') {
					return expression(input, this);
				}

		return null;
	}
}

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parses and executes Thymeleaf expressions.
 * 
 * TODO: Create a shared instance of this for a processing context so that it
 *       doesn't need to be recreated over and over.
 * 
 * @author Emanuel Rabina
 */
class ExpressionProcessor {

  /**
   * @param {Object} context
   */
  constructor() {
    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


    this.context = context;
  }

  /**
   * Parse and execute the given input as a Thymeleaf expression.
   * 
   * @param {String} input
   * @return {*}
   */
  process(input) {

    // TODO: Probably don't need to create a new parser every time?
    let parser = new Parser(ThymeleafExpressionLanguage);
    let expressionAction = parser.parse(input);
    return expressionAction ? expressionAction(this.context) : null;
  }
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common class for attribute processors.
 * 
 * TODO: Do we even need a class for processors?  So far they all seem to be
 *       functions that execute based on a name match, which for all intents can
 *       be as simple as an object name/function pair!
 * 
 * @author Emanuel Rabina
 */
class AttributeProcessor {

  /**
   * Constructor, sets this processor's prefix and name.
   * 
   * @param {String} prefix
   * @param {String} name
   */
  constructor(prefix, name) {

    this.prefix = prefix;
    this.name = name;
  }
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:attr` attribute processor, modifies or sets
 * a target attribute to whatever its associated expression evaluates to.
 * 
 * @author Emanuel Rabina
 */
class AttrAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `attr` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, AttrAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:attr` or `data-th-attr` attribute
  * on it, picking out the target attributes and setting them to whatever their
  * expressions evaluate to.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		// TODO: This regex, is this some kind of value list that needs to be
		//       turned into an expression?
		if (/(.+=.+,)*.+=.+/.test(attributeValue)) {
			attributeValue.split(',').forEach(attribute => {
				let attributeParts = attribute.split('=');
				element.setAttribute(attributeParts[0], escapeHtml(new ExpressionProcessor(context).process(attributeParts[1])));
			});
		}
		/* istanbul ignore next */
		else if (process.env.NODE_ENV !== 'test') {
				console.warn(`Value to ${attribute}, ${attributeValue}, doesn't seem to contain an attribute assignment expression.  Ignoring.`);
			}
		element.removeAttribute(attribute);
	}
}
AttrAttributeProcessor.NAME = 'attr';

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Thymeleaf's `th:checked` attribute processor, sets or removes the `checked`
 * attribute from an element based on the result of the expression within it.
 * 
 * TODO: This is one of HTML5s "boolean attributes", attributes whose values are
 *       true simply by being present in the element, regardless of the value
 *       inside it.  To act as false, the attribute has to be removed.  Find a
 *       way to generate these from some list of boolean attributes so that I
 *       don't need to write a class for each one!
 * 
 * @author Emanuel Rabina
 */
class CheckedAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `checked` name and supplied
  * prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, CheckedAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:checked` or `data-th-checked`
  * attribute on it, either setting or removing a `checked` attribute to the
  * current element based on the result of the inner expression.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		let result = new ExpressionProcessor(context).process(attributeValue);
		if (result) {
			element.setAttribute('checked', '');
		} else {
			element.removeAttribute('checked');
		}

		element.removeAttribute(attribute);
	}
}
CheckedAttributeProcessor.NAME = 'checked';

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The `th:classappend` is a special attribute that applies the expression to
 * any existing classes already on an element.
 * 
 * @author Emanuel Rabina
 */
class ClassAppendAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `attr` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, ClassAppendAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:classappend` or `data-th-classappend`
  * attribute on it, adding the resulting classes to any existing classes on
  * the current element.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		let classes = new ExpressionProcessor(context).process(attributeValue);
		if (classes) {
			element.className += ` ${classes}`;
		}
		element.removeAttribute(attribute);
	}
}
ClassAppendAttributeProcessor.NAME = 'classappend';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:each` attribute processor, iterates over an
 * [iterable object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols),
 * executing a piece of template for every iteration.
 * 
 * @author Emanuel Rabina
 */
class EachAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `each` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, EachAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:each`/`data-th-each` attribute,
  * repeating the markup for every object in the iterable value.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  * @return {Boolean} Whether or not the parent element needs to do a second
  *   pass as its children have been modified by this processor.
  */
	process(element, attribute, attributeValue, context) {

		element.removeAttribute(attribute);

		let iterationInfo = new ExpressionProcessor(context).process(attributeValue);
		if (iterationInfo) {
			let localValueName = iterationInfo.localValueName,
			    iterable = iterationInfo.iterable;

			let templateNode = element.cloneNode(true);

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					let value = _step.value;

					let localClone = templateNode.cloneNode(true);
					let localVariable = {};
					localVariable[localValueName] = value;

					// TODO: Standardize this data attribute somewhere.  Shared const?
					// element.dataset not yet implemented in JSDOM (https://github.com/tmpvar/jsdom/issues/961),
					// so until then we're setting data- attributes the old-fashioned way.
					localClone.setAttribute('data-thymeleaf-local-variables', JSON.stringify(localVariable));

					element.parentElement.appendChild(localClone);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}
		element.parentElement.removeChild(element);

		return true;
	}
}
EachAttributeProcessor.NAME = 'each';

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Configurable attribute processor that sets or empties an attribute value on
 * an element if the result of its expression is truthy or falsey respectively.
 * 
 * @author Emanuel Rabina
 */
class EmptyableAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set the name of the attribute this processor will operate on.
  * 
  * @param {String} prefix
  * @param {String} name
  */
	constructor(prefix, name) {

		super(prefix, name);
	}

	/**
  * Processes an element that contains the configured attribute to be worked
  * on, setting it if the expression resolves to a truthy value, or removing it
  * if it resolves to a falsey value.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		let value = new ExpressionProcessor(context).process(attributeValue);
		element.setAttribute(this.name, value ? value.toString() : '');
		element.removeAttribute(attribute);
	}
}

const EMPTYABLE_ATTRIBUTE_NAMES = ['href', 'src', 'value'];

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:fragment` attribute processor, marks an
 * element as a template fragment that can be imported by other processors like
 * `th:insert`.
 * 
 * @author Emanuel Rabina
 */
class FragmentAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `fragment` name and supplied
  * prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, FragmentAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:fragment` or `data-th-fragment`
  * attribute on it.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.removeAttribute(attribute);

		// TODO: Some off-context mechanism for encountered fragments?
		if (!context.fragments) {
			context.fragments = [];
		}
		context.fragments.push({
			name: attributeValue,
			element: element.cloneNode(true)
		});
	}
}
FragmentAttributeProcessor.NAME = 'fragment';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* global "node" */

/**
 * Removes all of an element's child nodes.
 * 
 * @param {Element} element
 */
function clearChildren(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

/**
 * Sets a Thymeleaf attribute and value on an existing element.  Used primarily
 * in tests.
 * 
 * @param {Element} element
 * @param {String} attribute
 * @param {String} value
 * @return {Element} The same element but with the attribute and value set on it.
 */


/**
 * Use either JSDOM or the browser's native DOM parsing to deserialize the HTML
 * string into a document fragment.
 * 
 * @param {String} htmlString
 * @return {DocumentFragment}
 */
function deserialize(htmlString) {
  return require('jsdom').jsdom(htmlString, {
    features: {
      FetchExternalResources: false,
      ProcessExternalResources: false
    }
  });
}

/**
 * Use either JSDOM or the browser's native DOM serialization to serialize a
 * document fragment into an HTML string.
 * 
 * @param {DocumentFragment} documentFragment
 * @return {String}
 */
function serialize(documentFragment) {
  return require('jsdom').serializeDocument(documentFragment);
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:if` attribute processor, includes or
 * excludes the current element and its children from rendering, depending on
 * the evaluation of the expression in the attribute value.
 * 
 * @author Emanuel Rabina
 */
class IfAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `if` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, IfAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:if` or `data-th-if` attribute
  * on it, evaluating the expression for truthy/falsey, rendering/excluding the
  * element and its children based on the result.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		let expressionResult = new ExpressionProcessor(context).process(attributeValue);
		if (!expressionResult) {
			clearChildren(element);
			element.parentNode.removeChild(element);
		}
		element.removeAttribute(attribute);
	}
}
IfAttributeProcessor.NAME = 'if';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = 'object' === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function (arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(
// In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());
});

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = function () {
  return this;
}() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

var runtimeModule = runtime;

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch (e) {
    g.regeneratorRuntime = undefined;
  }
}

var regenerator = runtimeModule;

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:insert` attribute processor, inserts the
 * referenced template fragment as a child of the current element.
 * 
 * @author Emanuel Rabina
 */
class InsertAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `insert` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, InsertAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:insert`/`data-th-insert` attribute,
  * replacing the current element's children with the DOM in the referenced
  * fragment.
  * 
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  * @return {Promise<Boolean>} Whether or not the parent element needs to do a
  *   second pass as its children have been modified by this processor.
  */
	process(element, attribute, attributeValue, context) {
		var _this = this;

		return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
			var templateResolver, fragmentInfo, templateName, fragmentName, template, standardDialect, dialectPrefix, fragmentProcessorName, fragment;
			return regenerator.wrap(function _callee$(_context) {
				while (1) switch (_context.prev = _context.next) {
					case 0:

						element.removeAttribute(attribute);
						clearChildren(element);

						templateResolver = context.templateResolver;

						if (!templateResolver) {
							_context.next = 20;
							break;
						}

						fragmentInfo = new ExpressionProcessor(context).process(attributeValue);

						if (!fragmentInfo) {
							_context.next = 18;
							break;
						}

						templateName = fragmentInfo.templateName, fragmentName = fragmentInfo.fragmentName;
						_context.t0 = deserialize;
						_context.next = 10;
						return templateResolver(templateName);

					case 10:
						_context.t1 = _context.sent;
						template = (0, _context.t0)(_context.t1);
						standardDialect = context.dialects.find(function (dialect) {
							return dialect.name === StandardDialect.NAME;
						});
						dialectPrefix = standardDialect.prefix;
						fragmentProcessorName = FragmentAttributeProcessor.NAME;
						fragment = $(`[${dialectPrefix}\\:${fragmentProcessorName}^="${fragmentName}"]`, template) || $(`[data-${dialectPrefix}-${fragmentProcessorName}^="${fragmentName}"`, template);


						element.appendChild(fragment);
						return _context.abrupt('return', true);

					case 18:
						_context.next = 21;
						break;

					case 20:
						console.log(`No template resolver configured, unable to locate fragment via ${attributeValue} processor`);

					case 21:
						return _context.abrupt('return', false);

					case 22:
					case 'end':
						return _context.stop();
				}
			}, _callee, _this);
		}))();
	}
}
InsertAttributeProcessor.NAME = 'insert';

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Configurable attribute processor that sets or removes an attribute on an
 * element if the result of its expression is truthy or falsey respectively.
 * 
 * @author Emanuel Rabina
 */
class RemovableAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set the name of the attribute this processor will operate on.
  * 
  * @param {String} prefix
  * @param {String} name
  */
	constructor(prefix, name) {

		super(prefix, name);
	}

	/**
  * Processes an element that contains the configured attribute to be worked
  * on, setting it if the expression resolves to a truthy value, or removing it
  * if it resolves to a falsey value.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		let value = new ExpressionProcessor(context).process(attributeValue);
		if (value) {
			element.setAttribute(this.name, value.toString());
		} else {
			element.removeAttribute(this.name);
		}

		element.removeAttribute(attribute);
	}
}

const REMOVABLE_ATTRIBUTE_NAMES = ['class'];

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:text` attribute processor, applies the
 * expression in the attribute value to the text content of the element being
 * processed, escaping any unsafe input.
 * 
 * @author Emanuel Rabina
 */
class TextAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `text` name and supplied prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, TextAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:text` or `data-th-text` attribute
  * on it, taking the text expression in the value and applying it to the text
  * content of the element.
  * 
  * @param {Element} element 
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.textContent = new ExpressionProcessor(context).process(attributeValue);
		element.removeAttribute(attribute);
	}
}
TextAttributeProcessor.NAME = 'text';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * JS equivalent of Thymeleaf's `th:utext` attribute processor, applies the
 * expression in the attribute value to the text content of the element being
 * processed.
 * 
 * @author Emanuel Rabina
 */
class UTextAttributeProcessor extends AttributeProcessor {

	/**
  * Constructor, set this processor to use the `utext` name and supplied
  * prefix.
  * 
  * @param {String} prefix
  */
	constructor(prefix) {

		super(prefix, UTextAttributeProcessor.NAME);
	}

	/**
  * Processes an element that contains a `th:utext` or `data-th-utext`
  * attribute on it, taking the text expression in the value and applying it to
  * the text content of the element.
  *
  * @param {Element} element
  *   Element being processed.
  * @param {String} attribute
  *   The attribute that was encountered to invoke this processor.
  * @param {String} attributeValue
  *   The value given by the attribute.
  * @param {Object} context
  */
	process(element, attribute, attributeValue, context) {

		element.innerHTML = new ExpressionProcessor(context).process(attributeValue);
		element.removeAttribute(attribute);
	}
}
UTextAttributeProcessor.NAME = 'utext';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common class for dialects.
 * 
 * @author Emanuel Rabina
 */
class Dialect {

  /**
   * Constructor, sets this dialect's name and prefix.
   * 
   * @param {String} name
   * @param {String} prefix
   */
  constructor(name, prefix) {

    this.name = name;
    this.prefix = prefix;
  }
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The out-of-the-box dialect for Thymeleaf, the "Standard Dialect".
 * 
 * @author Emanuel Rabina
 */
class StandardDialect extends Dialect {

	/**
  * Create an instance of this dialect with the name "Standard" and
  * given prefix, defaulting to "th" if not supplied.
  * 
  * @param {String} [prefix='thjs']
  */
	constructor() {
		let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StandardDialect.DEFAULT_PREFIX;


		super(StandardDialect.NAME, prefix);
	}

	/**
  * Returns the supported standard processors.
  * 
  * @return {Array} A list of the processors included in this dialect.
  */
	get processors() {

		// TODO: This is a very basic way of imposing the order of attribute
		//       processors.  It's currently ordered in the same way as OG
		//       Thymeleaf.  Figure out a 'proper' way to do the ordering.

		// Order taken from https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence
		let prefix = this.prefix;

		return [].concat(
		// Fragment inclusion
		new InsertAttributeProcessor(prefix),

		// Fragment iteration
		new EachAttributeProcessor(prefix),

		// Conditional evaluation
		new IfAttributeProcessor(prefix),

		// Local variable definition
		new AttrAttributeProcessor(prefix), new ClassAppendAttributeProcessor(prefix),

		// General attribute modification
		EMPTYABLE_ATTRIBUTE_NAMES.map(attributeName => {
			return new EmptyableAttributeProcessor(prefix, attributeName);
		}), REMOVABLE_ATTRIBUTE_NAMES.map(attributeName => {
			return new RemovableAttributeProcessor(prefix, attributeName);
		}),

		// Specific attribute modification
		new CheckedAttributeProcessor(prefix),

		// Text
		new TextAttributeProcessor(prefix), new UTextAttributeProcessor(prefix),

		// Fragment specification
		new FragmentAttributeProcessor(prefix)

		// Fragment removal
		);
	}
}
StandardDialect.NAME = 'Standard';
StandardDialect.DEFAULT_PREFIX = 'thjs';

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Configuration object for the template engine.
 * 
 * @typedef {Object} Configuration
 * @property {Array<Dialect>} dialects
 *   A list of dialects to include with this instance of the template engine.
 * @property {Object} [isomorphic]
 *   An object which configures the isomorphic capabilities of the template
 *   engine.
 * @property {Function} templateResolver
 *   A function for returning the text of templates named by fragment
 *   expressions in templates.  Is given only 1 argument, the template name from
 *   a fragment expression, and should return a Promise of the template text.
 */

/**
 * Default configuration for the template engine, configures the standard
 * dialect with no options (uses `thjs` as the prefix).
 * 
 * @type {Configuration}
 */
const DEFAULT_CONFIGURATION = {
  dialects: [new StandardDialect()]
};

/**
 * Standard configuration, configures the standard dialect with the `th` prefix
 * and enables isomorphic mode which enables the ability to use much of the same
 * processors across original Thymeleaf and ThymeleafJS.
 * 
 * @type {Configuration}
 */
const STANDARD_CONFIGURATION = _extends({}, DEFAULT_CONFIGURATION, {
  dialects: [new StandardDialect('th')],
  isomorphic: {
    prefix: 'thjs'
  }
});

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Matcher {

	/**
  * Create a matcher to work with the current context and isomorphic processing
  * settings.
  * 
  * @param {Object} context
  * @param {Object} isomorphic
  */
	constructor(context, isomorphic) {

		this.context = context;
		this.isomorphic = isomorphic;
	}

	/**
  * Return the matching attribute of an element that a processor can work over.
  * 
  * @param {Element} element
  * @param {AttributeProcessor} processor
  * @return {String}
  *   The attribute that matched processing by this processor, or `null` if no
  *   match was found.
  */
	matches(element, processor) {

		let prefixes = [].concat(this.isomorphic ? this.isomorphic.prefix : [], processor.prefix);
		let name = processor.name;
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {

			for (var _iterator = prefixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				let prefix = _step.value;

				let attribute;
				attribute = `${prefix}:${name}`;
				if (element.hasAttribute(attribute)) {
					return attribute;
				}
				attribute = `data-${prefix}-${name}`;
				if (element.hasAttribute(attribute)) {
					return attribute;
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return null;
	}
}

/* 
 * Copyright 2018, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert a standard node callback-style function into a function that returns
 * a Promise.
 * 
 * @param {Function} func
 * @return {Function}
 */
function promisify(func) {
  return function () {
    return new Promise((resolve, reject) => {
      func(...arguments, (error, result) => {
        if (error) {
          reject(new Error(error));
        } else {
          resolve(result);
        }
      });
    });
  };
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const XML_NAMESPACE_ATTRIBUTE = `xmlns:${StandardDialect.DEFAULT_PREFIX}`;

/**
 * A highly-configurable class responsible for processing the Thymeleaf
 * directives found in HTML documents and fragments.
 * 
 * @author Emanuel Rabina
 */
class TemplateEngine {

	/**
  * Constructor, set up a new template engine instance.
  * 
  * @param {Object} config
  */
	constructor() {
		var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_CONFIGURATION;

		let dialects = _ref.dialects,
		    isomorphic = _ref.isomorphic,
		    templateResolver = _ref.templateResolver;


		this.dialects = dialects;
		this.isomorphic = isomorphic;
		this.processors = flatten(dialects.map(dialect => dialect.processors));
		this.templateResolver = templateResolver;
	}

	/**
  * Process the Thymeleaf template data, returning the processed template.
  * 
  * @param {String} template
  * @param {Object} [context={}]
  * @return {Promise<String>}
  *   A promise resolved with the processed template, or rejected with an error
  *   message.
  */
	process(template) {
		let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


		let document = deserialize(template);
		let rootElement = document.firstElementChild;
		return this.processNode(rootElement, _extends({}, context, {
			dialects: this.dialects,
			templateResolver: this.templateResolver
		})).then(() => {
			// TODO: Special case, remove the xmlns:th namespace from the document.
			//       This should be handled like in main Thymeleaf where it's just
			//       another processor that runs on the document.
			if (rootElement.hasAttribute(XML_NAMESPACE_ATTRIBUTE)) {
				rootElement.removeAttribute(XML_NAMESPACE_ATTRIBUTE);
			}
			return serialize(document);
		});
	}

	/**
  * Process the Thymeleaf template at the given path, returning a promise of the
  * processed template.
  * 
  * @param {String} filePath
  * @param {Object} [context={}]
  * @return {Promise<String>}
  *   A promise resolved with the processed template, or rejected with an error
  *   message.
  */
	processFile(filePath) {
		let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


		/* global "node" */
		return promisify(require('fs').readFile)(filePath).then(data => {
			return this.process(data, context);
		});
	}

	/**
  * Process a DOM element.
  * 
  * @private
  * @param {Element} element
  * @param {Object} [context={}]
  * @return {Promise<Boolean>} Whether or not the parent node needs reprocessing.
  */
	processNode(element) {
		var _arguments = arguments,
		    _this = this;

		return asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
			let context = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};

			var localVariables, localContext, matcher, requireReprocessing, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, processor, attribute, processorResult, reprocess, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, child;

			return regenerator.wrap(function _callee$(_context) {
				while (1) switch (_context.prev = _context.next) {
					case 0:

						// TODO: Standardize this data attribute somewhere.  Shared const?
						// element.dataset not yet implemented in JSDOM (https://github.com/tmpvar/jsdom/issues/961),
						// so until then we're getting data- attributes the old-fashioned way.
						// Alternatively, some kind of variable stack that pops with each move up
						// the DOM.
						localVariables = JSON.parse(element.getAttribute('data-thymeleaf-local-variables'));

						element.removeAttribute('data-thymeleaf-local-variables');
						localContext = merge({}, context, localVariables);
						matcher = new Matcher(context, _this.isomorphic);

						// Process the current element, store whether or not reprocessing of the
						// parent needs to happen before moving on to this element's children.

						requireReprocessing = false;
						_iteratorNormalCompletion = true;
						_didIteratorError = false;
						_iteratorError = undefined;
						_context.prev = 8;
						_iterator = _this.processors[Symbol.iterator]();

					case 10:
						if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
							_context.next = 25;
							break;
						}

						processor = _step.value;
						attribute = matcher.matches(element, processor);

						if (!attribute) {
							_context.next = 19;
							break;
						}

						_context.next = 16;
						return processor.process(element, attribute, element.getAttribute(attribute), localContext);

					case 16:
						_context.t0 = _context.sent;
						_context.next = 20;
						break;

					case 19:
						_context.t0 = false;

					case 20:
						processorResult = _context.t0;

						requireReprocessing = requireReprocessing || processorResult;

					case 22:
						_iteratorNormalCompletion = true;
						_context.next = 10;
						break;

					case 25:
						_context.next = 31;
						break;

					case 27:
						_context.prev = 27;
						_context.t1 = _context['catch'](8);
						_didIteratorError = true;
						_iteratorError = _context.t1;

					case 31:
						_context.prev = 31;
						_context.prev = 32;

						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}

					case 34:
						_context.prev = 34;

						if (!_didIteratorError) {
							_context.next = 37;
							break;
						}

						throw _iteratorError;

					case 37:
						return _context.finish(34);

					case 38:
						return _context.finish(31);

					case 39:
						if (!requireReprocessing) {
							_context.next = 41;
							break;
						}

						return _context.abrupt('return', true);

					case 41:
						reprocess = false;
						_iteratorNormalCompletion2 = true;
						_didIteratorError2 = false;
						_iteratorError2 = undefined;
						_context.prev = 45;
						_iterator2 = element.children[Symbol.iterator]();

					case 47:
						if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
							_context.next = 57;
							break;
						}

						child = _step2.value;
						_context.next = 51;
						return _this.processNode(child, localContext);

					case 51:
						reprocess = _context.sent;

						if (!reprocess) {
							_context.next = 54;
							break;
						}

						return _context.abrupt('break', 57);

					case 54:
						_iteratorNormalCompletion2 = true;
						_context.next = 47;
						break;

					case 57:
						_context.next = 63;
						break;

					case 59:
						_context.prev = 59;
						_context.t2 = _context['catch'](45);
						_didIteratorError2 = true;
						_iteratorError2 = _context.t2;

					case 63:
						_context.prev = 63;
						_context.prev = 64;

						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}

					case 66:
						_context.prev = 66;

						if (!_didIteratorError2) {
							_context.next = 69;
							break;
						}

						throw _iteratorError2;

					case 69:
						return _context.finish(66);

					case 70:
						return _context.finish(63);

					case 71:
						if (reprocess) {
							_context.next = 41;
							break;
						}

					case 72:
					case 'end':
						return _context.stop();
				}
			}, _callee, _this, [[8, 27, 31, 39], [32,, 34, 38], [45, 59, 63, 71], [64,, 66, 70]]);
		}))();
	}
}

/* 
 * Copyright 2017, Emanuel Rabina (http://www.ultraq.net.nz/)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { STANDARD_CONFIGURATION, TemplateEngine, Dialect, AttributeProcessor, StandardDialect };
//# sourceMappingURL=thymeleaf.node.es.js.map
